\section{Objetos e classes}

\begin{frame}[fragile]{Objetos e referências}

    \begin{itemize}
        \item Em Smalltalk, todos os tipos de dados são \textbf{objetos}

        \item Objetos podem ser \textbf{instanciados} por meio de constantes ou da mensagem
            \code{smalltalk}{new}

            \inputsyntax{smalltalk}{codes/objects.st}

        \item A atribuição faz com que a variável \textbf{referencie} o objeto construído à
            direita

        \item Assim, uma mesma variável pode mudar sua referência por meio de nova 
            atribuição

            \inputsyntax{smalltalk}{codes/refs.st}

        \item Quando um objeto fica sem referência, sua memória será \textbf{desalocada} pelo
            \textit{garbage collector} em algum momento

        \item O operador \textbf{exclamação} (\texttt{!}) libera a referência

            \inputsyntax{smalltalk}{codes/gc.st}
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Mensagens e métodos}

    \begin{itemize}
        \item Em Smalltalk, as \textbf{mensagens} são o principal meio de comunicação entre os
            diferentes objetos

        \item Uma mensagem é composta por um \textbf{método} da classe, seguido de dois pontos 
            (\texttt{:}) e seus parâmetros, separados por um espaço em branco, caso existam

        \item Uma série de mensagens cujo destinatário é o mesmo objeto podem ser concatenadas
            por meio do operador \textbf{ponto-e-vírgula} (\texttt{;})
 
        \item O valor da expressão será o retorno da última mensagem

            \inputsyntax{smalltalk}{codes/messages.st}

        \item Mensagens para objetos distintos podem ser concatenadas por meio do operador
            \textbf{ponto final} (\texttt{.})

            \inputsyntax{smalltalk}{codes/dot.st}
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Classes}

    \begin{itemize}
        \item Em Smalltalk, as \textbf{classes} são organizadas em um árvore hierárquica, cuja
            raiz é a classe \code{smalltalk}{Object}

        \item A sintaxe para a declaração de uma classe é

            \inputsyntax{smalltalk}{codes/class.st}

        \item Ou seja, uma nova classe é criada enviando-se a mensagem \code{smalltalk}{subclass}
            para a classe \textbf{Object}

        \item \textbf{Variáveis de instância} são criadas por meio da mensagem 
            \code{smalltalk}{instanceVariableNames}

            \inputsyntax{smalltalk}{codes/members.st}

        \item A mensagem \code{smalltalk}{comment} pode ser utilizada para documentar a classe
 
            \inputsyntax{smalltalk}{codes/comment.st}
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Classes}

    \begin{itemize}
        \item Os métodos podem ser redefinidos, se necessário

            \inputsyntax{smalltalk}{codes/newcomment.st}

        \item Há outra sintaxe, mais próxima da utilizada em outras linguagens, para a 
            definição de uma classe:

            \inputsyntax{smalltalk}{codes/polygon.st}

        \item Uma classe já definida pode ser estendida para adicionar novos membros ou métodos

            \inputsyntax{smalltalk}{codes/extend.st}

    \end{itemize}

\end{frame}


\begin{frame}[fragile]{Classes}

    \begin{itemize}
        \item Um novo método de instância pode ser definido usando a  sintaxe

            \inputsyntax{smalltalk}{codes/method.st}

        \item Para definir um método de classe, a palavra-reservada \code{smalltalk}{extend} deve
            ser precedida da palavra reservada \code{smalltalk}{class}

            \inputsyntax{smalltalk}{codes/classmethod.st}
    \end{itemize}

\end{frame}
\begin{frame}[fragile]{Classes}

    \begin{itemize}
        \item Para criar novas instâncias da classe, é preciso definir o método \code{smalltalk}{new}

        \item Este método, em sua implementação, deve
        \begin{enumerate}
            \item Criar uma variável que conterá o espaço de memória da instância
            \item Inicializar este espaço invocando o método \code{smalltalk}{new} de sua
                superclasse
            \item Inicializar as variáveis de instância da classe
            \item Retornar a variável que contém a instância
        \end{enumerate}

        \item Para \textbf{retornar} um valor ao término da execução de um método, deve-se
            preceder o valor do retorno do operador `\texttt{\^}'

        \item Se o método não tiver um retorno explícito, será retornada a própria instância por
            padrão

        \item Para definir como um instância de uma classe será impressa, deve-se sobreescrever
            o método \code{smalltalk}{printOn}

    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exemplo de implementação de métodos de classe e instância}
    \inputcode{smalltalk}{codes/new.st}
\end{frame}

\begin{frame}[fragile]{Definição completa da classe \code{smalltalk}{Polygon}}
    \inputcode{smalltalk}{codes/polygonclass.st}
\end{frame}

\begin{frame}[fragile]{{\tt gst}, arquivos e imagens}

    \begin{itemize}
        \item Um arquivo pode ser carregado no \texttt{gst} por meio do método
            \code{smalltalk}{fileIn} da classe \code{smalltalk}{FileStream}:

            \inputsyntax{smalltalk}{codes/filein.st}

        \item Todas as definições já inseridas em uma sessão do \texttt{gst} podem ser 
            salvas em um arquivo imagem, através do método \code{smalltalk}{snapshot} da
            classe \code{smalltalk}{ObjectMemory}

            \inputsyntax{smalltalk}{codes/snapshot.st}

        \item Esta imagem pode ser carregada na inicialização do \texttt{gst}:

            \inputsyntax{bash}{codes/gst.sh}

        \item Uma vez carregada a imagem, a sessão anterior fica reestabelecida, no que
            diz respeito as \textbf{definições} das classes feitas anteriormente

        \item Atribuições à variáveis \textbf{não são salvas}
    \end{itemize}

\end{frame}
